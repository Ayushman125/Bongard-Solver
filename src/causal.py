# Folder: bongard_solver/src/causal.py

import logging
from typing import List, Dict, Any, Tuple, Optional
import random

# Import BongardRule from bongard_rules
try:
    from bongard_rules import BongardRule
except ImportError:
    logging.warning("Could not import BongardRule in Causal. Using dummy BongardRule.")
    class BongardRule:
        def __init__(self, name, description, program_ast, logical_facts):
            self.name = name
            self.description = description
            self.program_ast = program_ast
            self.logical_facts = logical_facts
        def __repr__(self): return self.name

logger = logging.getLogger(__name__)

class CausalFilter:
    """
    Causal Filtering module for Bongard problems.
    This module takes a list of candidate rules (e.g., from ILP) and
    applies heuristic causal filtering to select or prioritize rules
    that are more likely to represent the underlying causal mechanism
    of the Bongard problem.

    In a real system, this could involve:
    - Checking for sufficiency and necessity
    - Minimality criteria (Occam's Razor)
    - Consistency with counterfactuals
    - Integration with a causal graph learning module
    """
    def __init__(self):
        logger.info("CausalFilter initialized.")

    @classmethod
    def filter(cls, candidate_rules: List[BongardRule]) -> List[BongardRule]:
        """
        Filters and prioritizes candidate rules based on heuristic causal principles.
        Args:
            candidate_rules (List[BongardRule]): A list of BongardRule objects proposed by ILP.
        Returns:
            List[BongardRule]: A filtered and potentially re-ordered list of rules.
        """
        logger.info(f"CausalFilter: Filtering {len(candidate_rules)} candidate rules.")
        
        if not candidate_rules:
            logger.warning("CausalFilter: No candidate rules to filter.")
            return []

        filtered_rules: List[BongardRule] = []

        # Heuristic 1: Prioritize simpler rules (e.g., fewer logical operators, fewer components)
        # This is a very basic proxy for "causal minimality"
        def get_rule_complexity(rule: BongardRule) -> int:
            # A very simple complexity metric: number of logical facts + number of AST nodes
            num_facts = len(rule.logical_facts) if rule.logical_facts else 0
            
            # Count nodes in AST (recursive helper)
            def count_nodes(node_dict: Dict[str, Any]) -> int:
                count = 1 # Count the current node
                if "args" in node_dict:
                    for arg in node_dict["args"]:
                        count += count_nodes(arg)
                return count
            
            ast_node_count = 0
            if rule.program_ast and isinstance(rule.program_ast, list) and rule.program_ast:
                ast_node_count = count_nodes(rule.program_ast[0]) # Assuming first element is root
            
            return num_facts + ast_node_count

        # Sort rules by complexity (ascending)
        sorted_rules = sorted(candidate_rules, key=get_rule_complexity)
        
        # Heuristic 2: Deduplicate identical rules (based on logical facts)
        unique_rules_by_facts: Dict[Tuple[str, ...], BongardRule] = {}
        for rule in sorted_rules:
            # Use a sorted tuple of logical facts as a key for uniqueness
            facts_tuple = tuple(sorted(rule.logical_facts))
            if facts_tuple not in unique_rules_by_facts:
                unique_rules_by_facts[facts_tuple] = rule
            else:
                logger.debug(f"CausalFilter: Deduplicated rule: {rule.name} (identical to {unique_rules_by_facts[facts_tuple].name})")
        
        filtered_rules = list(unique_rules_by_facts.values())

        # Heuristic 3: Simple "plausibility" check (e.g., rules should contain at least one attribute or relation)
        # This is already somewhat handled by ILP, but can be a final sanity check.
        # For this example, we'll assume rules generated by ILP are plausible enough.

        logger.info(f"CausalFilter: Filtered down to {len(filtered_rules)} rules.")
        return filtered_rules

